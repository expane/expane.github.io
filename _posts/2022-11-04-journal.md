---
layout: post
title: 联考日记
categories: [record]
tags: []
toc: true
math: true
---

# 1104T3 排列

$T$ 组数据。

给出排列 $p_1,p_2\cdots,p_n$，可以进行三种操作：
1. 花费 $a$ 的代价，将排列的两个相邻位置交换。
2. 花费 $b$ 的代价，将排列翻转。
3. 花费 $c$ 的代价，将排列随机打乱。

$T\le 10^5, n\le 16$

### 题解

显然答案只于逆序对个数有关。预处理 $f_i$ 表示逆序对个数为 $i$ 的排列数。

有个贪心是，每次将代价最大的逆序对数的策略改成随机，直到变劣。于是双指针。

复杂度 $O(Tn^2)$

# 1104T4 树上二维偏序问题

有一棵有根树，每个节点上写着 `0/1/?`。你要将所有 `?` 替换为 `0/1`，最大化价值。

价值定义为，满足如下条件点对 $(u,v)$ 数量：$u$ 为 $v$ 祖先，且 $a_u=0,a_v=v$。

每次修改一个点上写的字符后询问最大价值，询问间不独立。

$n,q\le 2\times 10^5$

部分分：无 `?`、$n,q\le 2000$、链。

### 部分分

无 `?`：……

$n,q\le 2000$：注意到 `?` 替换成的 `0/1` 一定祖先为 `0` 后代为 `1`。每次 DP，设 $f_i$ 表示子树 $i$ 的祖先都选 `?` 时，子树里的 `1` 对答案的贡献。转移 `naive`。

链：感性理解，分界点至多移动 `1`，因此维护所有 `?` 的出现位置，暴力修改分界处的字符。

（qwq，最后20min觉得什么都写不出来，怎么办）

### 题解

先钦定 `?` 都是 `1`，再换成 `0`。

设 $g_i$ 表示 `?` 节点 $i$ 的祖先 `?` 都是 `0` 的情况下，$i$ 选 `0` 优多少。

可以发现越靠根 $g$ 越大，因此贪心正确，答案是初始钦定值 `\sum\max(g_i,0)`。

修改对 `g` 的影响为子树、链加减 $1$。

询问分块，然后对关键点建虚树分块，要满足每次修改都能拆成 $O(n/B)$ 个整块操作。

块内直接开桶。

# 1105T2 灌篮高手

给出长为 $n(n+1)$ 的序列 $a$，求一个长为 $2n$ 的子序列，满足其中排名 $2k-1$ 和 $2k$ 的元素在子序列中相邻。

### 题解

每 $n+1$ 个数分一块。

每次找出次小值最小的块，取出其中最小值和次小值，然后删除其他块内的最小值，规约到子问题。

块内排序即可。

（qwq，不会构造）

# 1105T3 森林

维护森林，每次在点 $x,y$ 分别所在树根处连边 $(a_i,b_i)$，新的树根为 $y$。

问森林内，$\dfrac{\|\sum b_i\|}{\sum a_i}$ 最小的路径的这个值下取整。

$n\le 9\times 10^4, a_i\le 10, b_i\le 10^{13}$

### 题解

一眼 dsu on tree。鉴定为数据结构：
1. 整体加
2. 插入点
3. 查询与给定点斜率绝对值的最小值

考虑 k-d tree。复杂度 $O(n\sqrt n\log n)$ （跑不满）。

k-d tree 的神必剪枝：
1. 用当前树根更新答案。
2. 用子树的包围矩形估计下界，如果不可能更新答案则跳过。
3. 否则，**先搜索**下界小的一侧子树。（k-d tree 灵魂所在？）

# 1105T4 见证者

求 $n\times m$ 网格图的完美匹配数量。$n,m\le 500$。

### 题解

特判 $n,m$ 都是奇数。不妨设 $2\|m$。

黑白染色。考虑让行列式帮我们枚举匹配。

钦定一个初始匹配——每个点和左右邻居连边。

![](/assets/pic/0000.jpg)

现在每个匹配对应一些偶环。我们希望每个偶环的贡献是 $1$ 而不是 $-1$。

![](/assets/pic/0001.jpg)

考虑环经过的竖直边的数量。注意到从一条向右横边到向左横边经过的竖边数量一定是奇数，而一个环一定同时包含这两种横边，因此将环拆成两条链，分别都是奇数，故经过的竖直边总数一定模四余二。给竖直边 $\sqrt{-1}$ 的权值即可。

消元求行列式类似于解方程，即有一些变量 $x_{i,j}$，只跟周围四个有限制。

经典 trick，用十字上面四个表示最下面一个。这样相当于用 $x_{1,i}$ 表示整个矩阵，做一遍是 $O(n^3)$ 的。

![](/assets/pic/0002.jpg)

消完的矩阵右侧 $(n-1)m$ 列每列都只有一个数，因此我们只需计算左下 $m\times m$ 矩阵的行列式。

# 1107T3 基础数论练习题

初始 $x=0$，每次选择一个 $[1,n]$ 内的随机整数 $y$ 并令 $x=\gcd(x,y)$，问 $x$ 变成 $y$ 的期望步数。

$n\le 10^{10},m=\prod_{i=1}^w p_i^{a_i},w\le 40$

### 题解

考虑容斥，设 $\mu'(n)$ 满足

$$\sum_{d\mid n}\mu'(d)=[n\mid m]$$

答案为

$$
\begin{aligned}
&1-\sum_{d\ge 2}\mu'(d)\sum_{i\ge 1} \left(\dfrac{\lfloor n/d\rfloor}{n}\right)^i\\
=&1-\sum_{d\ge 2}\mu'(d)f(\lfloor n/d\rfloor)
\end{aligned}
$$

$\mu'(n)$ 的前缀和可以杜教筛，需要求 $n$ 以内 $m$ 的因数个数，可以添加质因子 DP，前缀和优化一下。

通过 $\sum_{j\le k}\mu'(p_i^j)=[k\le a_i]$ 可以解出 $\mu'(n)$ 的表达式，可以线性筛预处理。

复杂度 $O(n^{2/3}+w\sqrt n)$

# 1107T4 基础 NPC 练习题

构造一个点数尽量多的无向完全图，并给其中的每一条边染色，颜色数不超过 $k$，使得没有同色三元环。

$k\le 6,n_{1,2,\cdots,6} = \{2, 5, 16, 45, 139, 416\}$

### 题解

手玩能找出前两个。退火多随几次能跑出前三个。（qwq，场上我以为暴力跑不出来，且自己能玩出来，全寄）

有一个神秘点数 $\times 3$ 的做法。

就是分成三组，每组和组间的边套 $k-1$ 的构造，颜色轮换一下。

暴搜能搜出 $k=4$ 的排列。然后……事实上只有最后三个轮换前面保持不变是可以的。

对于 $1\sim k-3$ 这些颜色，只看在组内的编号就能知道不可能有三元环。

剩下的正确性证明都是 dirty work。

# 1108T2 阵
构造一个 $n\times m$ 的矩阵，满足：
1. $1\sim nm$ 恰出现一次
2. $\forall 1<i<n,1\le j\le m$ 都有 $A_{x,y}\perp A_{x-1,y}\lor A_{x,y}\perp A_{x+1,y}$
3. $\forall 1\le i\le n,1<j<m$ 都有 $A_{x,y}\perp A_{x,y-1}\lor A_{x,y}\perp A_{x,y+1}$
4. $a_{x,y}=z$

### 题解

考虑 $\gcd(n,n+1)=1$，且 $\gcd(1, n)=1$，事实上只要排成一个环然后轮换。

每两行蛇皮一下，最后若剩下一行直接走过去，发现符合题意。

发现 $\gcd(1, x)=1$ 但没发现 $\gcd(1, n)=1$ 怎么办？？？

又忘了有解输出 `Yes`。。。

# 1108T4 块

我在玩只由 $1\times k$ 的方块组成的神秘俄罗斯方块。

现在有一个宽度为 $n$ 的平面，开始时第 $i$ 列的最下方 $a_i$ 个格子上有方块。

每一回合，你需要在无穷高处放置一个 $1\times k$ 的方块（横或竖），他会不断下落，直到其底面碰到了地面或其他方块。

如果在某一时刻，某一行的所有列上都有方块，那么这一行会立即消失并且上面的所有方块会下落一格。

如果此时平面内没有任何方块，游戏结束。

请你判断是否可以结束游戏，如果可以，请你在不超过 $10^4$ 次操作，并保证最大高度不超过 $1000$ 的情况下完成游戏。

$n,k\le 50$

部分分：$\forall i\in[k,n], a_i=0$

### 题解

先只考虑每一列有多少方块。

三种操作：
1. 整体减 $1$
2. 长为 $k$ 的区间整体加 $1$
3. 单点加 $k$

那么只需在模 $k$ 意义下考虑 $a_i$，考虑差分数组，发现若设 $s_j$ 表示 $\sum_{i\equiv j\pmod k}a_i$，
那么 $s$ 序列的 $[1,n\bmod k]$ 与 $(n\bmod k, k]$ 区间分别模 $k$ 全等。

这是有解的必要条件，事实上也是充分的。考虑构造。

首先，可以将所有 $\le max-k$ 的位置加上 $k$，这相当于取模。

对于部分分，这意味着 $[n\bmod k+1,n]$ 都是 $0$。只要摆满横着的即可。

任意情况考虑变成部分分。先在 $[1,n-1]$ 堆上一些将 $a_n$ 变成 $0$。

从后往前扫，现在要将 $a_i$ 变成 $0$，那么将其补成 $[i-k+1,i]$ 区间最大值，并在此横着放 $k-a_i$ 个。

其余部分竖着堆一些，把刚才的横块消除。这样一来 $[i+1,n]$ 区间就 $\equiv a_i$ 了！

然后做完了。